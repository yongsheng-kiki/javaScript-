<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    // 全局作用域： 当打开页面时，形成一个全局的作用域；
    // 私有作用域： 函数每执行一次，都会形成一个新的私有作用域；
    // 作用域： 1.给代码提供运行环境 2.存储基本数据类型值；
    /*console.log(a)// undefined
    var  a = 10;
    console.log(a);*/// 10

    // 全局变量 私有变量
    // 全局： 在全局的作用域被var或被function都是全局变量
    // 给window新增一个键值对；


    // 1.私有变量的判断：
        // 1. 在私有作用域下有没有被var过；
        // 2. 有没有被function
        // 3. 是不是形参；

   /* var f = 17;
    function fn() {

    }
    h = 19;
    function sum() {
        console.log(h)// undefined
        var h = 1;
    }*/

    // 1.

    /*var num = 10;
    function gg() {
        console.log(num)
        //var  num =18;
        function num() {

        }
    }
    gg(12)*/

    // 函数执行：
    // 1. 形成私有作用域
    // 2. 形参赋值
    // 3. 变量提升
    // 4. 代码从上到下运行
    // 5. 作用域是否销毁；



    // 变量提升
    // 声明： 通知当前作用域有这么一个变量；
    //作用域---> 变量提升阶段 ---> 代码运行；

    /*function g() {
        var  f  = 9;
    }*/

    //变量提升特殊情况：
    // 1.不管条件是否成立，都要进行变量提升
    // 2.变量提升只发生在=左边
    // 3.return后面的内容不进行变量提升；但是下面的代码要进行变量提升
    // 4.变量名重复；不再进行声明，但要重新定义
    // 5. 匿名函数不进行变量提升
    // 6. let  const 不进行变量提升；
    /*console.log(num);// 函数
    var  num = 10;
    function num() {

    }
    var num;*/

    // 查找上一级作用域： 跟函数在哪定义有关，跟函数在哪执行没有任何关系；
    /*var total =19;
    function f(){
        var  total =10;
        return function () {
            console.log(total);
        }
    };*/


    // 堆内存的销毁：
   /* var  f = {};
    f = null;
    function g() {

    }*/
    /*var ary = [13,4,5,7,0];
    var  len = 1000;
    for(var i=0;i<ary.length;i++){
        if(!isNaN(ary[i])){
            total += ary[i];
        }
    }*/

    //





























</script>
</body>
</html>